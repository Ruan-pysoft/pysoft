${page_title = "Screaming into the void";}$
${page_description = "Random thoughts and things from me";}$
${header();}$
<h1>$(page_title)$</h1>
<i>Like a tweet, but more robotic</i>
${
#define BLIPS_PER_PAGE 100

File_Paths blip_files = {0};
const char *blips_dir = WORKING_DIR"/blips/";
if (!read_entire_dir(blips_dir, &blip_files)) return 1;

struct {
    struct blip *items;
    size_t count;
    size_t capacity;
} blips = {0};

for (size_t i = 0; i < BLIPS_PER_PAGE + 42; ++i) {
    nob_da_append(&blips, ((struct blip) {
        .year = 2026,
        .month = 2,
        .day = 20,
        .index = i,

        .slug = temp_sprintf("autogend-%03lu", i),
        .has_time = false,
        .hour = 0,
        .minute = 0,

        .content = temp_sprintf("Hi there, this is the %lu-th test blip", i),
    }));
}

da_foreach(const char *, it, &blip_files) {
    const size_t mark = temp_save();

    const char *blip_file = *it;
    if (strcmp(blip_file, ".") == 0 || strcmp(blip_file, "..") == 0) {
        continue;
    }
    const char *path = temp_sprintf("%s/%s", blips_dir, blip_file);

    switch (get_file_type(path)) {
    case FILE_REGULAR: {
        nob_da_append(&blips, parse_blip(blip_file, path));
    } break;
    case FILE_DIRECTORY: {
        nob_log(WARNING, "Found directory in blips folder: ", blip_file);
    } break;
    case FILE_SYMLINK: {
        nob_log(WARNING, "Found symlink in blips folder: ", blip_file);
    } break;
    case FILE_OTHER: {
        nob_log(WARNING, "Found strange file in blips folder: ", blip_file);
    } break;
    }

    temp_rewind(mark);
}

blips_sort(blips.items, blips.count);
// get reverse chronological order:
struct blip tmp;
for (size_t i = 0; i < blips.count/2; ++i) {
    tmp = blips.items[blips.count - i - 1];
    blips.items[blips.count - i - 1] = blips.items[i];
    blips.items[i] = tmp;
}

da_foreach(struct blip, blip, &blips) {
    const size_t mark = temp_save();

    create_site_dir(temp_sprintf("blips/%04d%02d%02d", blip->year, blip->month, blip->day));
    const char *blip_url = temp_sprintf("blips/%04d%02d%02d/%s.html", blip->year, blip->month, blip->day, blip->slug);

    FILE *blip_file = create_site_file(blip_url);
    OUTFILE = blip_file;

    const char *saved_title = page_title;
    const char *saved_description = page_description;
    const char *saved_extra = head_extra;
    const char *saved_license = license_extra;

    page_title = temp_sprintf("%s – blip", blip->slug);
    page_description = temp_sprintf("a random thought about \"%s\"", blip->slug);
    head_extra = NULL;
    license_extra = NULL;

    header();
    }$
    <article class="blip">
    <p>$(blip->content)$</p>
    </article>
    ${
    if (blip->has_time) {}$
        <div class="blip-time">Time posted: $("%02d:%02d", blip->hour, blip->minute)$ SAST</div>
    ${}
    footer();

    page_title = saved_title;
    page_description = saved_description;
    head_extra = saved_extra;
    license_extra = saved_license;

    OUTFILE = stdout;
    fclose(blip_file);

    }$
    ${

    temp_rewind(mark);
}

const size_t on_first_page = blips.count < BLIPS_PER_PAGE ? blips.count : BLIPS_PER_PAGE;
const size_t pages = (blips.count + BLIPS_PER_PAGE-1)/BLIPS_PER_PAGE;
}$
<h2>Most Recent Blips</h2>
<p>Here are the $("%d", on_first_page)$ most recent blips:<p>
${
for (size_t i = 0; i < on_first_page; ++i) {
    struct blip *blip = &blips.items[i];
    }$
    <h3>$(blip->slug)$ – blip on $("%04d-%02d-%02d", blip->year, blip->month, blip->day)$</h3>
    <article class="blip">
    <p>$(blip->content)$</p>
    </article>
    ${
    if (blip->has_time) {}$
        <div class="blip-time">Time posted: $("%02d:%02d", blip->hour, blip->minute)$ SAST</div>
    ${}
    }$<hr>${
}
}$
${footer();}$
